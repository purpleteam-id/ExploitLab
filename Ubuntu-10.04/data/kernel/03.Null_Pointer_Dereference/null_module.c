#include <linux/device.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/mutex.h>
#include <linux/uaccess.h>
#include <linux/cred.h>

#define DEVICE_NAME "null_device_danang"
#define CLASS_NAME "null_device_danang"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Danang Heriyadi <danang@purpleteam.id>");
MODULE_DESCRIPTION("Add null pointer vuln module kernel.");
MODULE_VERSION("0.1");

static int Major;
static struct class *dev_class;
static struct device *dev_device;
static char message[256] = {0};
static DEFINE_MUTEX(ioMutex);
static int numberOpens = 0;
static short  messageSize;
dev_t dev=0;

static int dev_open(struct inode *inode, struct file *file)
{
	// Reservasi file
    if(!mutex_trylock(&ioMutex)) {
        pr_alert("%s: device in use by another process", DEVICE_NAME);
        return -EBUSY;
    }
	numberOpens++;
	return 0;
}
static int dev_release(struct inode *inode, struct file *file)
{
	mutex_unlock(&ioMutex);
	return 0;
}

void (*null_function_ptr)(void);

static ssize_t dev_write(struct file *inode, const char *buff, size_t len, loff_t *loff)
{
    memcpy(message, buff, len);
	messageSize = len;
    printk(KERN_INFO "null_device_danang: received %zu characters from the user\n", len);
    printk(KERN_INFO "null_device_danang: the message is -> %s\n", message);
	if (strcmp(message, "cobacoba\n") == 0){ // <---
		null_function_ptr();
	}
	return len;
}

static ssize_t dev_read(struct file *filep, char *buffer, size_t len, loff_t *offset){
   return 0;
}

// Mendefinisikan operasi file
static struct file_operations fops = {
	.write = dev_write, // Akan ke trigger ketika user menulis ke device /dev/null_device_danang
	.read = dev_read, // Akan ke trigger ketika user membaca file /dev/null_device_danang
	.open = dev_open, // Akan ke trigger ketika user membuka file /dev/null_device_danang
	.release = dev_release // Akan ketrigger ketika user menutup file /dev/null_device_danang
};

int init_module(void)
{
	// Tujuan: Membuat device / file, lokasinya adalah /dev/null_device_danang
	printk(KERN_INFO "null_device_danang: Hello module kernel...\n");
	mutex_init(&ioMutex);

	// izin dulu /dev/null_device_danang
	Major = register_chrdev(0, DEVICE_NAME, &fops);
	if (IS_ERR(Major)) // -1, -2, ...
	{
		// Akan ke trigger ketika device lokasi /dev/null_device_danang itu sudah ada yg punya
		printk(KERN_ALERT "null_device_danang: Registering char device failed with %d\n", Major);
		return Major; // Return as disappointed / Pulang dengan kecewa -1
	}

	// Reservasi /dev/null_device_danang
	dev_class = class_create(THIS_MODULE, CLASS_NAME);
	if (IS_ERR(dev_class)){
		unregister_chrdev(Major, DEVICE_NAME); // IZIN gag jadi pake
		printk(KERN_ALERT "null_device_danang: Registering class device failed.\n");
		return -1; // Return as disappointed / Pulang dengan kecewa -1
	}

	// Membuat device
	dev_device = device_create(dev_class, NULL, MKDEV(Major, 0), NULL, DEVICE_NAME);
	if (IS_ERR(dev_device)){
		class_destroy(dev_class); // Ya udah gag jadi reservasi
		unregister_chrdev(Major, DEVICE_NAME); // Ya udah gag jadi izin
		printk(KERN_ALERT "null_device_danang: Registering device failed.\n");
		return -1; // Return as disappointed / Pulang dengan kecewa -1
	}

	// Muncul file / device baru lokasinya /dev/null_device_danang
	return 0; // Pulang dengan bahagia karena berhasil buat device (return 0)
}

void cleanup_module(void)
{
	printk(KERN_INFO "Goodbye module kernel...\n");
	device_destroy(dev_class, MKDEV(Major, 0)); // Nyuruh android untuk hapus /dev/null_device_danang
	class_destroy(dev_class); // Kasih kabar reservasi selesai
	unregister_chrdev(Major, DEVICE_NAME); // Kasih kabar izin nya udah selesai
	mutex_destroy(&ioMutex);
}
